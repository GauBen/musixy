{"mappings":"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","sources":["assets/app/marker.ts","assets/app/app.ts","assets/app/home-app.ts"],"sourcesContent":["export interface MarkerSettings {\n  x: [number, number]\n  y: [number, number]\n  width: number\n  height: number\n  pixelRatio: number\n}\n\nexport interface Point {\n  x: number\n  y: number\n}\n\nexport type Direction = 'NE' | 'NW' | 'SE' | 'SW'\n\nexport class Vector implements Point {\n  readonly x: number\n  readonly y: number\n\n  constructor(x: number, y: number)\n  constructor(v: Vector | Point)\n  constructor(x: number | Vector | Point, y: number | undefined = undefined) {\n    if (x instanceof Vector || (x instanceof Object && 'x' in x && 'y' in x)) {\n      this.x = x.x\n      this.y = x.y\n      return\n    }\n\n    this.x = x\n    this.y = y\n  }\n\n  static orthographicProjection(\n    startPoint: Point,\n    endPoint: Point,\n    projectile: Point\n  ) {\n    const v = new Vector(endPoint).sub(startPoint).normalize()\n    return new Vector(\n      v.scale(new Vector(projectile).sub(startPoint).dot(v))\n    ).add(startPoint)\n  }\n\n  add(v: Point) {\n    return new Vector(this.x + v.x, this.y + v.y)\n  }\n\n  sub(v: Point) {\n    return new Vector(this.x - v.x, this.y - v.y)\n  }\n\n  scale(s: number) {\n    return new Vector(this.x * s, this.y * s)\n  }\n\n  rotate(theta: number) {\n    return new Vector(\n      this.x * Math.cos(theta) - this.y * Math.sin(theta),\n      this.x * Math.sin(theta) + this.y * Math.cos(theta)\n    )\n  }\n\n  len2() {\n    return this.x * this.x + this.y * this.y\n  }\n\n  len() {\n    return Math.sqrt(this.len2())\n  }\n\n  dot(v: Point) {\n    return v.x * this.x + v.y * this.y\n  }\n\n  normalize() {\n    const length = this.len()\n    if (length < Number.EPSILON || !length) {\n      throw new Error('Division by zero')\n    }\n\n    return new Vector(this.x / length, this.y / length)\n  }\n}\n\nexport class Marker {\n  protected canvas: HTMLCanvasElement\n  protected context: CanvasRenderingContext2D\n\n  protected fromX: number\n  protected fromY: number\n  protected toX: number\n  protected toY: number\n\n  protected width: number\n  protected height: number\n  protected pixelRatio: number\n\n  constructor(\n    canvas: HTMLCanvasElement,\n    {\n      x: [fromX, toX],\n      y: [fromY, toY],\n      width,\n      height,\n      pixelRatio\n    }: MarkerSettings\n  ) {\n    this.canvas = canvas\n    this.context = canvas.getContext('2d')\n\n    this.fromX = fromX\n    this.fromY = fromY\n    this.toX = toX\n    this.toY = toY\n\n    this.resize(width, height, pixelRatio)\n    this.clear()\n  }\n\n  resize(width: number, height: number, pixelRatio: number) {\n    this.width = width\n    this.height = height\n    this.pixelRatio = pixelRatio\n\n    this.canvas.width = width * pixelRatio\n    this.canvas.height = height * pixelRatio\n    this.canvas.style.width = `${width}px`\n    this.canvas.style.height = `${height}px`\n\n    this.context.lineWidth = 3 * pixelRatio\n  }\n\n  clear() {\n    this.context.clearRect(\n      0,\n      0,\n      this.width * this.pixelRatio,\n      this.height * this.pixelRatio\n    )\n    this.context.lineJoin = 'round'\n    this.context.lineCap = 'round'\n    this.context.lineWidth = 2 * this.pixelRatio\n    this.context.fillStyle = '#000'\n    this.context.strokeStyle = '#000'\n  }\n\n  drawArrow(from: Point, to: Point) {\n    const canvasFrom = this.toCanvasVector(from)\n    const canvasTo = this.toCanvasVector(to)\n    const ctx = this.context\n    const arrow = canvasTo.sub(canvasFrom).normalize()\n    ctx.beginPath()\n    ctx.moveTo(canvasFrom.x, canvasFrom.y)\n    ctx.lineTo(canvasTo.x - arrow.x * 10, canvasTo.y - arrow.y * 10)\n    ctx.stroke()\n\n    ctx.beginPath()\n    ctx.moveTo(canvasTo.x, canvasTo.y)\n    const firstPoint = canvasTo.add(\n      arrow.scale(20 * this.pixelRatio).rotate((3 * Math.PI) / 4)\n    )\n    const secondPoint = canvasTo.add(\n      arrow.scale(20 * this.pixelRatio).rotate((5 * Math.PI) / 4)\n    )\n    ctx.lineTo(firstPoint.x, firstPoint.y)\n    ctx.lineTo(secondPoint.x, secondPoint.y)\n    ctx.closePath()\n    ctx.fillStyle = '#000'\n    ctx.fill()\n  }\n\n  drawPolyLine(\n    points: Point[],\n    color: string | CanvasGradient | CanvasPattern = null\n  ) {\n    const ctx = this.context\n\n    let canvasVector = this.toCanvasVector(points[0])\n    ctx.beginPath()\n    ctx.moveTo(canvasVector.x, canvasVector.y)\n\n    for (const point of points.slice(1)) {\n      canvasVector = this.toCanvasVector(point)\n      ctx.lineTo(canvasVector.x, canvasVector.y)\n    }\n\n    ctx.strokeStyle = color\n    ctx.stroke()\n  }\n\n  drawPoint(\n    point: Point,\n    radiusPx = 10,\n    color: string | CanvasGradient | CanvasPattern = null\n  ) {\n    const ctx = this.context\n\n    const center = this.toCanvasVector(point)\n    ctx.beginPath()\n    ctx.arc(center.x, center.y, radiusPx * this.pixelRatio, 0, 7, false)\n    ctx.fillStyle = '#fff'\n    ctx.fill()\n    ctx.strokeStyle = color\n    ctx.lineWidth = (radiusPx / 2.5) * this.pixelRatio\n    ctx.stroke()\n  }\n\n  drawCircle(\n    point: Point,\n    radius: number,\n    color: string | CanvasGradient | CanvasPattern = null\n  ) {\n    const ctx = this.context\n    const radiusPx =\n      (radius / (this.toX - this.fromX)) * this.width * this.pixelRatio\n    const center = this.toCanvasVector(point)\n    ctx.beginPath()\n    ctx.arc(center.x, center.y, radiusPx, 0, 7, false)\n    ctx.fillStyle = '#fff'\n    ctx.fill()\n    ctx.strokeStyle = color\n    ctx.lineWidth = 2\n    ctx.stroke()\n  }\n\n  drawText(text: string, point: Point, direction: Direction) {\n    const ctx = this.context\n    const margin = 5 * this.pixelRatio\n    const h = 20 * this.pixelRatio\n    ctx.font = `${h}px \"Segoe UI\"`\n    const vect = this.toCanvasVector(point)\n    const w = ctx.measureText(text).width\n\n    switch (direction) {\n      case 'NE':\n        ctx.fillText(text, vect.x + margin, vect.y - margin)\n        break\n\n      case 'NW':\n        ctx.fillText(text, vect.x - w - margin, vect.y - margin)\n        break\n\n      case 'SE':\n        ctx.fillText(text, vect.x + margin, vect.y + h + margin)\n        break\n\n      case 'SW':\n        ctx.fillText(text, vect.x - w - margin, vect.y + h + margin)\n        break\n\n      default:\n        throw new Error('Invalid argument for type Direction')\n    }\n  }\n\n  toCanvasVector(point: Point): Vector {\n    return new Vector(\n      ((point.x - this.fromX) / (this.toX - this.fromX)) *\n        this.width *\n        this.pixelRatio,\n      ((-point.y - this.fromY) / (this.toY - this.fromY)) *\n        this.height *\n        this.pixelRatio\n    )\n  }\n\n  fromCanvasPoint(point: Point): Vector {\n    return new Vector(\n      (point.x / this.width) * (this.toX - this.fromX) + this.fromX,\n      (1 - point.y / this.height) * (this.toY - this.fromY) + this.fromY\n    )\n  }\n}\n","import {Marker} from './marker'\n\nexport type JSONSong = [string, number, number, string, string, number]\nexport type JSONDataBase = {\n  axes: [string, string, string, string]\n  songs: JSONSong[]\n}\n\nexport type state = Promise<() => state>\n\nexport const listen = async <K extends keyof HTMLElementEventMap>(\n  element: HTMLElement,\n  eventName: K\n) =>\n  new Promise<HTMLElementEventMap[K]>((resolve) => {\n    element.addEventListener(\n      eventName,\n      (event) => {\n        resolve(event)\n      },\n      {once: true}\n    )\n  })\n\nexport const escapeHtml = (string: string) =>\n  string\n    .replace(/&/g, '&amp;')\n    .replace(/</g, '&lt;')\n    .replace(/>/g, '&gt;')\n    .replace(/\"/g, '&quot;')\n\nexport abstract class App {\n  protected board: HTMLCanvasElement\n  protected marker: Marker\n\n  constructor(board: HTMLCanvasElement) {\n    this.board = board\n    this.marker = new Marker(board, {\n      x: [-1, 1],\n      y: [-1, 1],\n      width: 400,\n      height: 400,\n      pixelRatio: window.devicePixelRatio\n    })\n  }\n\n  init() {\n    this.marker.clear()\n    this.marker.drawArrow({x: -0.98, y: 0}, {x: 0.98, y: 0})\n    this.marker.drawArrow({x: 0, y: -0.98}, {x: 0, y: 0.98})\n    this.marker.drawText('Sad', {x: -0.03, y: -1}, 'NW')\n    this.marker.drawText('Happy', {x: -0.08, y: 1}, 'SW')\n    this.marker.drawText('Calm', {x: -1, y: 0}, 'SE')\n    this.marker.drawText('Energetic', {x: 0.9, y: 0}, 'SW')\n  }\n\n  run() {\n    throw new Error('Unimplemented exception')\n  }\n}\n","import {Vector} from './marker'\nimport {App, state, escapeHtml, listen, JSONDataBase, JSONSong} from './app'\n\nconst songToVect = (song: JSONSong) => new Vector(song[1], song[2])\n\nexport class HomeApp extends App {\n  $duration: HTMLInputElement\n  db: JSONDataBase\n\n  async run() {\n    this.setupSlider()\n\n    this.db = await (await fetch('./songs.json')).json()\n    for (let i = 0; i < 1000; i++)\n      this.db.songs.push([\n        'l0q7MLPo-u8',\n        Math.random() * 2 - 1,\n        Math.random() * 2 - 1,\n        'The Sound of Silence',\n        'Simon & Garfunkel',\n        187\n      ])\n\n    this.init()\n\n    let state: state = this.initialState()\n    while (true) {\n      const transition: () => state = await state\n      state = transition()\n    }\n  }\n\n  setupSlider() {\n    this.$duration = document.querySelector('#duration')\n    const $tooltip = document.querySelector('#duration-tooltip')\n    this.$duration.addEventListener('input', () => {\n      $tooltip.innerHTML = `${this.$duration.value} min`\n    })\n  }\n\n  init() {\n    this.marker.clear()\n    this.marker.drawArrow({x: -0.98, y: 0}, {x: 0.98, y: 0})\n    this.marker.drawArrow({x: 0, y: -0.98}, {x: 0, y: 0.98})\n    this.marker.drawText(this.db.axes[0], {x: -0.03, y: -1}, 'NW')\n    this.marker.drawText(this.db.axes[1], {x: -0.08, y: 1}, 'SW')\n    this.marker.drawText(this.db.axes[2], {x: -1, y: 0}, 'SE')\n    this.marker.drawText(this.db.axes[3], {x: 0.9, y: 0}, 'SW')\n  }\n\n  async initialState(): state {\n    const event = await listen(this.board, 'click')\n    const point: Vector = this.marker.fromCanvasPoint({\n      x: event.offsetX,\n      y: event.offsetY\n    })\n    return async () => this.state2(point)\n  }\n\n  async state2(lastPoint: Vector): state {\n    const drawArrow = (event: MouseEvent) => {\n      const point: Vector = this.marker.fromCanvasPoint({\n        x: event.offsetX,\n        y: event.offsetY\n      })\n      this.init()\n      const length = lastPoint.sub(point).len()\n      if (length >= 0.2) this.marker.drawArrow(lastPoint, point)\n      else if (length >= Number.EPSILON)\n        this.marker.drawCircle(lastPoint, length, '#000')\n    }\n\n    this.board.addEventListener('mousemove', drawArrow)\n\n    const event = await listen(this.board, 'click')\n    const point: Vector = this.marker.fromCanvasPoint({\n      x: event.offsetX,\n      y: event.offsetY\n    })\n    this.board.removeEventListener('mousemove', drawArrow)\n    if (lastPoint.sub(point).len() <= Number.EPSILON)\n      return async () => this.state2(point)\n    return async () => this.fetchPlaylist(lastPoint, point)\n  }\n\n  async fetchPlaylist(from: Vector, to: Vector): state {\n    this.init()\n    this.marker.drawArrow(from, to)\n    const duration = 60 * Number(this.$duration.value)\n    const length = to.sub(from).len()\n    const playlist =\n      length >= 0.2\n        ? this.makePathPlaylist(from, to, duration)\n        : this.makeCirclePlaylist(from, to, duration)\n\n    return async () => this.displayPlaylist(from, to, playlist)\n  }\n\n  makeCirclePlaylist(from: Vector, to: Vector, duration: number) {\n    const distances: Array<[number, JSONSong]> = []\n    for (const song of this.db.songs) {\n      distances.push([from.sub(songToVect(song)).len2(), song])\n    }\n\n    distances.sort((a, b) => {\n      const [p1] = a\n      const [p2] = b\n      return p2 - p1\n    })\n\n    const playlist: JSONSong[] = []\n    while (duration > 0 && distances.length > 0) {\n      const [, song] = distances.pop()!\n      playlist.push(song)\n      duration -= song[5]\n    }\n\n    return playlist\n  }\n\n  makePathPlaylist(from: Vector, to: Vector, duration: number) {\n    const playlist: Array<[number, JSONSong]> = []\n\n    const allSongs = this.db.songs\n\n    const projections: Array<[number, Vector, JSONSong]> = []\n\n    let startSong = allSongs[0]\n    let startSongDistance = from.sub(songToVect(startSong)).len2()\n    let endSong = allSongs[0]\n    let endSongDistance = to.sub(songToVect(endSong)).len2()\n\n    for (const song of allSongs) {\n      const v = songToVect(song)\n      const projection = Vector.orthographicProjection(from, to, v)\n      const projectionLength2 = projection.sub(v).len2()\n      projections.push([projectionLength2, projection, song])\n\n      if (from.sub(v).len2() < startSongDistance) {\n        startSong = song\n        startSongDistance = from.sub(v).len2()\n      }\n\n      if (to.sub(v).len2() < endSongDistance) {\n        endSong = song\n        endSongDistance = to.sub(v).len2()\n      }\n    }\n\n    duration -= endSong === startSong ? startSong[5] : startSong[5] + endSong[5]\n\n    projections.sort((a, b) => {\n      const [p1] = a\n      const [p2] = b\n      return p1 - p2\n    })\n\n    const sections: Array<[number, Vector, Vector]> = [\n      [to.sub(from).len2(), from, to]\n    ]\n\n    while (duration > 0 && sections.length > 0) {\n      let maxSectionLength = sections[0][0]\n      let maxSection = sections[0]\n      let maxI = 0\n      for (const [i, section] of sections.slice(1).entries()) {\n        if (section[0] > maxSectionLength) {\n          maxSection = section\n          maxSectionLength = section[0]\n          maxI = i + 1\n        }\n      }\n\n      sections.splice(maxI, 1)\n\n      const sectionFrom = maxSection[1]\n      const sectionTo = maxSection[2]\n\n      for (const [i, [, projection, song]] of projections.entries()) {\n        if (song === startSong || song === endSong) continue\n        const t =\n          projection.sub(sectionFrom).dot(sectionTo.sub(sectionFrom)) /\n          sectionTo.sub(sectionFrom).len2()\n        if (t <= 0 || t >= 1) continue\n        projections.splice(i, 1)\n        playlist.push([projection.sub(from).len2(), song])\n        duration -= song[5]\n        const section1: [number, Vector, Vector] = [\n          projection.sub(sectionFrom).len2(),\n          sectionFrom,\n          projection\n        ]\n        const section2: [number, Vector, Vector] = [\n          sectionTo.sub(projection).len2(),\n          projection,\n          sectionTo\n        ]\n        sections.push(section1, section2)\n        break\n      }\n    }\n\n    playlist.sort((a, b) => {\n      const [p1] = a\n      const [p2] = b\n      return p1 - p2\n    })\n    const realPlaylist = playlist.map((x) => {\n      const [, y] = x\n      return y\n    })\n\n    realPlaylist.unshift(startSong)\n    if (startSong !== endSong) realPlaylist.push(endSong)\n    return realPlaylist\n  }\n\n  async displayPlaylist(from: Vector, to: Vector, playlist: JSONSong[]): state {\n    const $playlist = document.querySelector('#playlist')\n\n    if (playlist.length === 0) {\n      $playlist.innerHTML =\n        '<p class=\"user-instruction\"><strong>Error:</strong> the server created an empty playlist. Please retry later.</p>'\n      return async () => this.initialState()\n    }\n\n    let html = '<div class=\"wrapper\"><ul class=\"music-list\">'\n\n    for (const music of playlist) {\n      html += `<li class=\"item playlist-entry\">\n          <img class=\"cover\" src=\"https://i.ytimg.com/vi/${escapeHtml(\n            music[0]\n          )}/mqdefault.jpg\" alt=\"Thumbnail\" width=\"85.33\" height=\"48\">\n          <span class=\"title\">${escapeHtml(music[3])}</span>\n          <span class=\"artist\">${escapeHtml(music[4])}</span>\n        </li>`\n    }\n\n    html += '</ul></div>'\n    html += `<p class=\"youtube-link\"><a href=\"http://www.youtube.com/watch_videos?video_ids=${encodeURI(\n      playlist.map((music) => music[0]).join(',')\n    )}\" target=\"_blank\" rel=\"noopener\">Listen on YouTube</a></p>`\n    $playlist.innerHTML = html\n\n    return async () => this.drawPlaylist(from, to, playlist)\n  }\n\n  async drawPlaylist(from: Vector, to: Vector, playlist: JSONSong[]): state {\n    return new Promise((resolve) => {\n      const vectors = playlist.map((music) => new Vector(songToVect(music)))\n\n      const draw = (time: number) => {\n        const chain: Vector[] = []\n        let cumulatedLength = 0\n        let previous = vectors[0]\n        const dots = [previous]\n        chain.push(previous)\n\n        for (const vector of vectors.slice(1)) {\n          const delta = vector.sub(previous)\n          const length = delta.len()\n          cumulatedLength += length\n\n          if (time < cumulatedLength) {\n            chain.push(\n              previous.add(\n                delta.scale((time + length - cumulatedLength) / length)\n              )\n            )\n            break\n          }\n\n          dots.push(vector)\n          chain.push(vector)\n          previous = vector\n        }\n\n        this.init()\n        const length = from.sub(to).len()\n        if (length >= 0.2) this.marker.drawArrow(from, to)\n        else if (length >= Number.EPSILON)\n          this.marker.drawCircle(from, length, '#000')\n        this.marker.drawPolyLine(chain, '#F00')\n        for (const dot of dots) this.marker.drawPoint(dot, 4)\n        return time < cumulatedLength\n      }\n\n      let start = null\n      const frame = (t: number) => {\n        if (start === null) start = t\n        if (draw((t - start) * 0.001)) {\n          requestAnimationFrame(frame)\n        } else {\n          resolve(async () => this.initialState())\n        }\n      }\n\n      requestAnimationFrame(frame)\n    })\n  }\n}\n\nconst app = new HomeApp(document.querySelector('#board'))\nvoid app.run()\n"],"names":["$fe2deee094054b1c4f73628f7e1a20fe$export$a00f0b081d75722f","x","y","Object","startPoint","endPoint","projectile","v","sub","normalize","scale","dot","add","[object Object]","this","s","theta","Math","cos","sin","sqrt","len2","length","len","Number","EPSILON","Error","$fe2deee094054b1c4f73628f7e1a20fe$export$d9f9145a3d2de879","canvas","fromX","toX","fromY","toY","width","width1","height","height1","pixelRatio","pixelRatio1","context","getContext","resize","clear","style","lineWidth","clearRect","lineJoin","lineCap","fillStyle","strokeStyle","from","to","canvasFrom","toCanvasVector","canvasTo","ctx","arrow","beginPath","moveTo","lineTo","stroke","firstPoint","rotate","PI","secondPoint","closePath","fill","points","color","canvasVector","point","slice","radiusPx","center","arc","radius","text","direction","margin","h","font","vect","w","measureText","fillText","$a27cc13473502718283eb3243d23c944$export$ff95bcce2965a200","async","element","eventName","Promise","resolve","addEventListener","event","once","$a27cc13473502718283eb3243d23c944$export$5e20d0a3120d6c07","string","replace","$61742357686ccadc9759e9e3f3e817da$var$songToVect","song","board","marker","window","devicePixelRatio","drawArrow","drawText","setupSlider","db","fetch","json","i","songs","push","random","init","state","initialState","$duration","document","querySelector","$tooltip","innerHTML","value","axes","fromCanvasPoint","offsetX","offsetY","state2","lastPoint","drawCircle","removeEventListener","fetchPlaylist","duration","playlist","makePathPlaylist","makeCirclePlaylist","displayPlaylist","distances","sort","a","b","p1","p2","song1","pop","allSongs","projections","startSong","startSongDistance","endSong","endSongDistance","projection","orthographicProjection","projectionLength2","sections","maxSectionLength","maxSection","maxI","section","entries","splice","sectionFrom","sectionTo","i1","t","section1","section2","realPlaylist","map","unshift","$playlist","html","music","encodeURI","music1","join","drawPlaylist","vectors","draw","time","chain","cumulatedLength","previous","dots","vector","delta","drawPolyLine","drawPoint","start","frame","requestAnimationFrame","run"],"version":3,"file":"index.5ea8bab7.js.map"}