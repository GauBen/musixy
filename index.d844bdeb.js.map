{"mappings":"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","sources":["src/db.d.ts","src/lib/html.ts","src/marker.ts","src/home-app.ts"],"sourcesContent":["export type Music = [string, number, number, string, string, number]\nexport type Database = {\n  musixy: 1\n  axes: [string, string, string, string]\n  musics: Music[]\n}\n\nexport enum MusicFields {\n  YoutubeId = 0,\n  X = 1,\n  Y = 2,\n  Title = 3,\n  Artist = 4,\n  Duration = 5\n}\n","export const listen = async <K extends keyof HTMLElementEventMap>(\n  element: HTMLElement,\n  eventName: K\n) =>\n  new Promise<HTMLElementEventMap[K]>((resolve) => {\n    element.addEventListener(\n      eventName,\n      (event) => {\n        resolve(event)\n      },\n      {once: true}\n    )\n  })\n\nexport const escape = (string: string) =>\n  string\n    .replace(/&/g, '&amp;')\n    .replace(/</g, '&lt;')\n    .replace(/>/g, '&gt;')\n    .replace(/\"/g, '&quot;')\n","export interface MarkerSettings {\n  x: [number, number]\n  y: [number, number]\n  pixelsPerUnit: number\n  pixelRatio: number\n}\n\nexport interface Point {\n  x: number\n  y: number\n}\n\nexport type Direction = 'NE' | 'NW' | 'SE' | 'SW'\n\nexport class Vector implements Point {\n  readonly x: number\n  readonly y: number\n\n  constructor(x: number, y: number)\n  constructor(v: Vector | Point)\n  constructor(x: number | Vector | Point, y: number | undefined = undefined) {\n    if (x instanceof Vector || (x instanceof Object && 'x' in x && 'y' in x)) {\n      this.x = x.x\n      this.y = x.y\n      return\n    }\n\n    this.x = x\n    this.y = y\n  }\n\n  static orthographicProjection(\n    startPoint: Point,\n    endPoint: Point,\n    projectile: Point\n  ) {\n    const v = new Vector(endPoint).sub(startPoint).normalize()\n    return new Vector(\n      v.scale(new Vector(projectile).sub(startPoint).dot(v))\n    ).add(startPoint)\n  }\n\n  add(v: Point) {\n    return new Vector(this.x + v.x, this.y + v.y)\n  }\n\n  sub(v: Point) {\n    return new Vector(this.x - v.x, this.y - v.y)\n  }\n\n  scale(s: number) {\n    return new Vector(this.x * s, this.y * s)\n  }\n\n  rotate(theta: number) {\n    return new Vector(\n      this.x * Math.cos(theta) - this.y * Math.sin(theta),\n      this.x * Math.sin(theta) + this.y * Math.cos(theta)\n    )\n  }\n\n  len2() {\n    return this.x * this.x + this.y * this.y\n  }\n\n  len() {\n    return Math.sqrt(this.len2())\n  }\n\n  dot(v: Point) {\n    return v.x * this.x + v.y * this.y\n  }\n\n  normalize() {\n    const length = this.len()\n    if (length < Number.EPSILON || !length) {\n      throw new Error('Division by zero')\n    }\n\n    return new Vector(this.x / length, this.y / length)\n  }\n}\n\nexport class Marker {\n  protected canvas: HTMLCanvasElement\n  protected context: CanvasRenderingContext2D\n\n  protected fromX: number\n  protected fromY: number\n  protected toX: number\n  protected toY: number\n\n  protected pixelRatio: number\n  protected pixelsPerUnit: number\n\n  constructor(\n    canvas: HTMLCanvasElement,\n    {\n      x: [fromX, toX],\n      y: [fromY, toY],\n      pixelsPerUnit,\n      pixelRatio\n    }: MarkerSettings\n  ) {\n    this.canvas = canvas\n    this.context = canvas.getContext('2d')\n\n    this.fromX = fromX\n    this.fromY = fromY\n    this.toX = toX\n    this.toY = toY\n\n    this.resize(pixelsPerUnit, pixelRatio)\n    this.clear()\n  }\n\n  resize(pixelsPerUnit: number, pixelRatio: number) {\n    this.pixelsPerUnit = pixelsPerUnit\n    this.pixelRatio = pixelRatio\n\n    this.canvas.width = (this.toX - this.fromX) * pixelsPerUnit * pixelRatio\n    this.canvas.height = (this.toY - this.fromY) * pixelsPerUnit * pixelRatio\n    this.canvas.style.width = `${(this.toX - this.fromX) * pixelsPerUnit}px`\n    this.canvas.style.height = `${(this.toY - this.fromY) * pixelsPerUnit}px`\n\n    this.context.lineWidth = 3 * pixelRatio\n  }\n\n  clear() {\n    this.context.clearRect(0, 0, this.canvas.width, this.canvas.height)\n    this.context.lineJoin = 'round'\n    this.context.lineCap = 'round'\n    this.context.lineWidth = 2 * this.pixelRatio\n    this.context.fillStyle = '#000'\n    this.context.strokeStyle = '#000'\n  }\n\n  drawArrow(from: Point, to: Point) {\n    const canvasFrom = this.toCanvasVector(from)\n    const canvasTo = this.toCanvasVector(to)\n    const ctx = this.context\n    const arrow = canvasTo.sub(canvasFrom).normalize()\n    ctx.beginPath()\n    ctx.moveTo(canvasFrom.x, canvasFrom.y)\n    ctx.lineTo(canvasTo.x - arrow.x * 10, canvasTo.y - arrow.y * 10)\n    ctx.stroke()\n\n    ctx.beginPath()\n    ctx.moveTo(canvasTo.x, canvasTo.y)\n    const firstPoint = canvasTo.add(\n      arrow.scale(20 * this.pixelRatio).rotate((3 * Math.PI) / 4)\n    )\n    const secondPoint = canvasTo.add(\n      arrow.scale(20 * this.pixelRatio).rotate((5 * Math.PI) / 4)\n    )\n    ctx.lineTo(firstPoint.x, firstPoint.y)\n    ctx.lineTo(secondPoint.x, secondPoint.y)\n    ctx.closePath()\n    ctx.fillStyle = '#000'\n    ctx.fill()\n  }\n\n  drawPolyLine(\n    points: Point[],\n    color: string | CanvasGradient | CanvasPattern = null\n  ) {\n    const ctx = this.context\n\n    let canvasVector = this.toCanvasVector(points[0])\n    ctx.beginPath()\n    ctx.moveTo(canvasVector.x, canvasVector.y)\n\n    for (const point of points.slice(1)) {\n      canvasVector = this.toCanvasVector(point)\n      ctx.lineTo(canvasVector.x, canvasVector.y)\n    }\n\n    ctx.strokeStyle = color\n    ctx.stroke()\n  }\n\n  drawPoint(\n    point: Point,\n    radiusPx = 10,\n    color: string | CanvasGradient | CanvasPattern = null\n  ) {\n    const ctx = this.context\n\n    const center = this.toCanvasVector(point)\n    ctx.beginPath()\n    ctx.arc(center.x, center.y, radiusPx * this.pixelRatio, 0, 7, false)\n    ctx.fillStyle = '#fff'\n    ctx.fill()\n    ctx.strokeStyle = color\n    ctx.lineWidth = (radiusPx / 2.5) * this.pixelRatio\n    ctx.stroke()\n  }\n\n  drawCircle(\n    point: Point,\n    radius: number,\n    color: string | CanvasGradient | CanvasPattern = null\n  ) {\n    const ctx = this.context\n    const radiusPx = radius * this.pixelsPerUnit * this.pixelRatio\n    const center = this.toCanvasVector(point)\n    ctx.beginPath()\n    ctx.arc(center.x, center.y, radiusPx, 0, 7, false)\n    ctx.fillStyle = '#fff'\n    ctx.fill()\n    ctx.strokeStyle = color\n    ctx.lineWidth = 2\n    ctx.stroke()\n  }\n\n  drawText(text: string, point: Point, direction: Direction) {\n    const ctx = this.context\n    const margin = 5 * this.pixelRatio\n    const h = 20 * this.pixelRatio\n    ctx.font = `${h}px \"Segoe UI\"`\n    const vect = this.toCanvasVector(point)\n    const w = ctx.measureText(text).width\n\n    switch (direction) {\n      case 'NE':\n        ctx.fillText(text, vect.x + margin, vect.y - margin)\n        break\n\n      case 'NW':\n        ctx.fillText(text, vect.x - w - margin, vect.y - margin)\n        break\n\n      case 'SE':\n        ctx.fillText(text, vect.x + margin, vect.y + h + margin)\n        break\n\n      case 'SW':\n        ctx.fillText(text, vect.x - w - margin, vect.y + h + margin)\n        break\n\n      default:\n        throw new Error('Invalid argument for type Direction')\n    }\n  }\n\n  toCanvasVector(point: Point): Vector {\n    return new Vector(\n      (point.x - this.fromX) * this.pixelsPerUnit * this.pixelRatio,\n      (-point.y - this.fromY) * this.pixelsPerUnit * this.pixelRatio\n    )\n  }\n\n  fromCanvasPoint(point: Point): Vector {\n    return new Vector(\n      point.x / this.pixelsPerUnit + this.fromX,\n      (this.canvas.height - point.y) / this.pixelsPerUnit + this.fromY\n    )\n  }\n}\n","import {Database, Music, MusicFields} from './db.d'\nimport {escape, listen} from './lib/html'\nimport {Marker, Vector} from './marker'\n\nconst defaultDatabases = ['./db.json', './db2.json']\n\nconst musicToVect = (music: Music) =>\n  new Vector(music[MusicFields.X], music[MusicFields.Y])\n\ntype state = Promise<() => state>\n\nconst CIRCLE_TRESHOLD = 0.2\n\nexport class HomeApp {\n  /** Canvas element */\n  protected $board: HTMLCanvasElement\n\n  /** 2DContext drawer */\n  protected marker: Marker\n\n  /** The duration slider */\n  protected $duration: HTMLInputElement\n\n  /** The tooltip associated with the slider */\n  protected $tooltip: HTMLElement\n\n  /** Axes */\n  protected axes: Database['axes']\n\n  /** Loaded musics */\n  protected musics: Database['musics'] = []\n\n  /** Downloaded database files */\n  protected databases: Map<string, Database> = new Map()\n\n  /** Loaded databases */\n  protected loadedDatabases: Set<string>\n\n  /** Databases checked in settings panel */\n  protected checkedDatabases: Map<string, Set<string>> = new Map()\n\n  /** Current state of the automaton */\n  protected state: (...args: any) => state\n\n  /** Interface to choose loaded databases */\n  protected $databasePicker: HTMLElement\n\n  /** Custom event target */\n  protected eventTarget = new EventTarget()\n\n  constructor({\n    board,\n    duration,\n    tooltip,\n    databasePicker,\n    loadDatabase,\n    databaseUrl\n  }: {\n    board: HTMLCanvasElement\n    duration: HTMLInputElement\n    tooltip: HTMLElement\n    databasePicker: HTMLElement\n    loadDatabase: HTMLFormElement\n    databaseUrl: HTMLInputElement\n  }) {\n    this.$board = board\n    this.$duration = duration\n    this.$tooltip = tooltip\n    this.$databasePicker = databasePicker\n\n    this.marker = new Marker(board, {\n      x: [-1, 1],\n      y: [-1, 1],\n      pixelsPerUnit: 200,\n      pixelRatio: window.devicePixelRatio\n    })\n\n    this.$tooltip.innerHTML = `${this.$duration.value} min`\n    this.$duration.addEventListener('input', () => {\n      this.$tooltip.innerHTML = `${this.$duration.value} min`\n    })\n\n    loadDatabase.addEventListener('submit', async (event) => {\n      event.preventDefault()\n      await this.addDatabase(databaseUrl.value)\n      this.eventTarget.dispatchEvent(new CustomEvent('reloadDatabase'))\n    })\n  }\n\n  async addDatabase(url: string): Promise<void> {\n    const database: Database = await (await fetch(url)).json()\n\n    if (\n      typeof database !== 'object' ||\n      !('musixy' in database) ||\n      database.musixy !== 1\n    )\n      throw new Error('Wrong format')\n\n    this.databases.set(url, database)\n  }\n\n  /** Start the finite-state automaton */\n  async run(): Promise<never> {\n    let state: state = this.loadDatabase()\n    while (true) {\n      const transition: () => state = await state\n      state = transition()\n    }\n  }\n\n  /** Fetch the music database */\n  async loadDatabase(): state {\n    this.state = this.loadDatabase\n\n    // Load default databases\n    for (const [file, db] of await Promise.all<[string, Database]>(\n      defaultDatabases.map(async (file) =>\n        fetch(file) // Parallelly fetch files\n          .then(async (response) => response.json())\n          .then((db) => [file, db])\n      )\n    )) {\n      this.databases.set(file, db)\n    }\n\n    this.loadedDatabases = new Set([defaultDatabases[0]])\n    this.axes = this.databases.get(defaultDatabases[0]).axes\n    this.checkedDatabases.set(this.axes.join('/'), this.loadedDatabases)\n\n    this.hydrateDatabasePicker()\n\n    return async () => this.loadMusics()\n  }\n\n  /** Populates the database picker with all available databases */\n  hydrateDatabasePicker() {\n    const groups = new Map<string, string[]>()\n\n    this.$databasePicker.innerHTML = ''\n\n    for (const [name, db] of this.databases.entries()) {\n      const group = db.axes.join('/')\n      groups.set(group, [...(groups.get(group) ?? []), name])\n    }\n\n    for (const [i, dbs] of [...groups.values()].entries()) {\n      const $fieldset = document.createElement('fieldset')\n      const axes = this.databases.get(dbs.values().next().value as string).axes\n      const axesId = axes.join('/')\n\n      this.checkedDatabases.set(\n        axesId,\n        this.checkedDatabases.get(axesId) ?? new Set()\n      )\n\n      const $radio = document.createElement('input')\n      $radio.type = 'radio'\n      $radio.name = 'group'\n      $radio.id = `group-${i}`\n      $radio.checked = this.axes ? this.axes.join('/') === axesId : i === 0\n      const $label = document.createElement('label')\n      $label.htmlFor = $radio.id\n      $label.append(\n        $radio,\n        `↕ ${axes[0]} to ${axes[1]}, ↔ ${axes[2]} to ${axes[3]}`\n      )\n\n      $radio.addEventListener('input', () => {\n        if (!$radio.checked) return\n        this.loadedDatabases = this.checkedDatabases.get(axesId)\n        this.axes = axes\n        this.eventTarget.dispatchEvent(new CustomEvent('reloadDatabase'))\n      })\n\n      const $legend = document.createElement('legend')\n      $legend.append($label)\n      $fieldset.append($legend)\n\n      for (const [i, db] of dbs.entries()) {\n        const $p = document.createElement('p')\n        const $label = document.createElement('label')\n        const $checkbox = document.createElement('input')\n\n        $checkbox.type = 'checkbox'\n        $checkbox.id = `db-${i}`\n        $label.append($checkbox, db)\n        $p.append($label)\n        $fieldset.append($p)\n        $checkbox.checked = this.checkedDatabases.get(axesId).has(db)\n\n        $checkbox.addEventListener('input', () => {\n          const c = this.checkedDatabases.get(axesId)\n          if ($checkbox.checked) c.add(db)\n          else c.delete(db)\n          if (this.axes.join('/') === axesId) this.loadedDatabases = c\n          this.eventTarget.dispatchEvent(new CustomEvent('reloadDatabase'))\n        })\n      }\n\n      this.$databasePicker.append($fieldset)\n    }\n  }\n\n  loadMusics(): () => state {\n    this.musics = []\n    for (const database of this.loadedDatabases)\n      this.musics.push(...this.databases.get(database).musics)\n\n    return async () => this.resetApp()\n  }\n\n  resetApp(): () => state {\n    this.drawAxes()\n    const $playlist = document.querySelector('#playlist')\n    $playlist.innerHTML =\n      '<p class=\"user-instruction\">Click twice on the whiteboard to create a playlist</p>'\n    return async () => this.waitForFirstInput()\n  }\n\n  /** Wait for a click, a touch start or a drag start */\n  async waitForFirstInput(): state {\n    this.state = this.waitForFirstInput\n    return Promise.race([\n      (async () => {\n        const event = await listen(this.$board, 'click')\n        if (this.loadedDatabases.size === 0)\n          return async () => this.waitForFirstInput()\n        const point: Vector = this.marker.fromCanvasPoint({\n          x: event.offsetX,\n          y: event.offsetY\n        })\n        return async () => this.waitForSecondClick(point)\n      })(),\n      this.awaitReloadEvent()\n    ])\n  }\n\n  /** Wait for the second click */\n  async waitForSecondClick(lastPoint: Vector): state {\n    const drawPreview = (event: MouseEvent) => {\n      const point: Vector = this.marker.fromCanvasPoint({\n        x: event.offsetX,\n        y: event.offsetY\n      })\n      this.drawAxes()\n      this.drawPathPreview(lastPoint, point)\n    }\n\n    this.$board.addEventListener('mousemove', drawPreview)\n\n    const transition = await Promise.race([\n      (async () => {\n        // Wait for second click\n        const event = await listen(this.$board, 'click')\n\n        const point: Vector = this.marker.fromCanvasPoint({\n          x: event.offsetX,\n          y: event.offsetY\n        })\n\n        // Protect against double clicks\n        if (lastPoint.sub(point).len() <= Number.EPSILON)\n          return async () => this.waitForSecondClick(point)\n\n        return async () => this.makePlaylist(lastPoint, point)\n      })(),\n\n      this.awaitReloadEvent()\n    ])\n\n    this.$board.removeEventListener('mousemove', drawPreview)\n\n    return transition\n  }\n\n  async awaitReloadEvent(): Promise<() => state> {\n    // Const $select: HTMLSelectElement = document.querySelector('#database')\n    await new Promise((resolve) => {\n      this.eventTarget.addEventListener('reloadDatabase', resolve, {once: true})\n    })\n    this.hydrateDatabasePicker()\n    return async () => this.loadMusics()\n  }\n\n  /** Make a playlist based on the two points given */\n  makePlaylist(from: Vector, to: Vector): () => state {\n    this.drawAxes()\n    this.drawPathPreview(from, to)\n\n    const duration = 60 * Number(this.$duration.value)\n    const length = to.sub(from).len()\n    const playlist =\n      length >= CIRCLE_TRESHOLD\n        ? this.makeArrowPlaylist(from, to, duration)\n        : this.makeCirclePlaylist(from, to, duration)\n\n    localStorage.setItem(\n      'musixy-history',\n      JSON.stringify([\n        playlist,\n        ...(JSON.parse(\n          localStorage.getItem('musixy-history') ?? '[]'\n        ) as Music[][]).slice(0, 9)\n      ])\n    )\n\n    return async () => this.displayPlaylist(from, to, playlist)\n  }\n\n  /** If the two points are close, make a circular playlist */\n  makeCirclePlaylist(from: Vector, to: Vector, duration: number) {\n    const distances: Array<[number, Music]> = []\n    for (const music of this.musics) {\n      distances.push([from.sub(musicToVect(music)).len2(), music])\n    }\n\n    distances.sort((a, b) => {\n      const [p1] = a\n      const [p2] = b\n      return p2 - p1\n    })\n\n    const playlist: Music[] = []\n    while (duration > 0 && distances.length > 0) {\n      const [, music] = distances.pop()\n      playlist.push(music as Music)\n      duration -= music[MusicFields.Duration]\n    }\n\n    return playlist\n  }\n\n  /** If the two points are far, make a linear playlist */\n  makeArrowPlaylist(from: Vector, to: Vector, duration: number) {\n    const playlist: Array<[number, Music]> = []\n\n    const projections: Array<[number, Vector, Music]> = []\n\n    let firstMusic = this.musics[0]\n    let firstMusicDistance = from.sub(musicToVect(firstMusic)).len2()\n    let lastMusic = this.musics[0]\n    let lastMusicDistance = to.sub(musicToVect(lastMusic)).len2()\n\n    for (const music of this.musics) {\n      const v = musicToVect(music)\n      const projection = Vector.orthographicProjection(from, to, v)\n      const projectionLength = projection.sub(v).len2()\n      projections.push([projectionLength, projection, music])\n\n      if (from.sub(v).len2() < firstMusicDistance) {\n        firstMusic = music\n        firstMusicDistance = from.sub(v).len2()\n      }\n\n      if (to.sub(v).len2() < lastMusicDistance) {\n        lastMusic = music\n        lastMusicDistance = to.sub(v).len2()\n      }\n    }\n\n    duration -=\n      lastMusic === firstMusic\n        ? firstMusic[MusicFields.Duration]\n        : firstMusic[MusicFields.Duration] + lastMusic[MusicFields.Duration]\n\n    projections.sort((a, b) => {\n      const [p1] = a\n      const [p2] = b\n      return p1 - p2\n    })\n\n    const sections: Array<[number, Vector, Vector]> = [\n      [to.sub(from).len2(), from, to]\n    ]\n\n    while (duration > 0 && sections.length > 0) {\n      let maxSectionLength = sections[0][0]\n      let maxSection = sections[0]\n      let maxI = 0\n      for (const [i, section] of sections.slice(1).entries()) {\n        if (section[0] > maxSectionLength) {\n          maxSection = section\n          maxSectionLength = section[0]\n          maxI = i + 1\n        }\n      }\n\n      sections.splice(maxI, 1)\n\n      const sectionFrom = maxSection[1]\n      const sectionTo = maxSection[2]\n\n      for (const [i, [, projection, music]] of projections.entries()) {\n        if (music === firstMusic || music === lastMusic) continue\n        const t =\n          projection.sub(sectionFrom).dot(sectionTo.sub(sectionFrom)) /\n          sectionTo.sub(sectionFrom).len2()\n        if (t <= 0 || t >= 1) continue\n        projections.splice(i, 1)\n        playlist.push([projection.sub(from).len2(), music])\n        duration -= music[MusicFields.Duration]\n        const section1: [number, Vector, Vector] = [\n          projection.sub(sectionFrom).len2(),\n          sectionFrom,\n          projection\n        ]\n        const section2: [number, Vector, Vector] = [\n          sectionTo.sub(projection).len2(),\n          projection,\n          sectionTo\n        ]\n        sections.push(section1, section2)\n        break\n      }\n    }\n\n    playlist.sort((a, b) => {\n      const [p1] = a\n      const [p2] = b\n      return p1 - p2\n    })\n    const realPlaylist = playlist.map((x) => {\n      const [, y] = x\n      return y\n    })\n\n    realPlaylist.unshift(firstMusic)\n    if (firstMusic !== lastMusic) realPlaylist.push(lastMusic)\n    return realPlaylist\n  }\n\n  displayPlaylist(from: Vector, to: Vector, playlist: Music[]): () => state {\n    const $playlist = document.querySelector('#playlist')\n\n    if (playlist.length === 0) {\n      $playlist.innerHTML =\n        '<p class=\"user-instruction\"><strong>Error:</strong> the server created an empty playlist. Please retry later.</p>'\n      return async () => this.waitForFirstInput()\n    }\n\n    let html = '<div class=\"wrapper\"><ul class=\"music-list\">'\n\n    for (const music of playlist) {\n      html += `<li class=\"item playlist-entry\">\n          <img class=\"cover\" src=\"https://i.ytimg.com/vi/${escape(\n            music[0]\n          )}/mqdefault.jpg\" alt=\"Thumbnail\" width=\"85.33\" height=\"48\">\n          <span class=\"title\">${escape(music[MusicFields.Title])}</span>\n          <span class=\"artist\">${escape(music[MusicFields.Artist])}</span>\n        </li>`\n    }\n\n    html += '</ul></div>'\n    html += `<p class=\"youtube-link\"><a href=\"http://www.youtube.com/watch_videos?video_ids=${encodeURI(\n      playlist.map((music) => music[MusicFields.YoutubeId]).join(',')\n    )}\" target=\"_blank\" rel=\"noopener\">Listen on YouTube</a></p>`\n    $playlist.innerHTML = html\n\n    return async () => this.drawPlaylist(from, to, playlist)\n  }\n\n  async drawPlaylist(from: Vector, to: Vector, playlist: Music[]): state {\n    this.state = this.drawPlaylist\n\n    return Promise.race([\n      new Promise<() => state>((resolve) => {\n        const vectors = playlist.map((music) => musicToVect(music))\n\n        const draw = (time: number) => {\n          const chain: Vector[] = []\n          let cumulatedLength = 0\n          let previous = vectors[0]\n          const dots = [previous]\n          chain.push(previous)\n\n          for (const vector of vectors.slice(1)) {\n            const delta = vector.sub(previous)\n            const length = delta.len()\n            cumulatedLength += length\n\n            if (time < cumulatedLength) {\n              chain.push(\n                previous.add(\n                  delta.scale((time + length - cumulatedLength) / length)\n                )\n              )\n              break\n            }\n\n            dots.push(vector)\n            chain.push(vector)\n            previous = vector\n          }\n\n          this.drawAxes()\n          this.drawPathPreview(from, to)\n          this.marker.drawPolyLine(chain, '#F00')\n          for (const dot of dots) this.marker.drawPoint(dot, 4)\n          return time < cumulatedLength\n        }\n\n        let start: number | null = null\n        const frame = (t: number) => {\n          if (this.state !== this.drawPlaylist) return\n          if (start === null) start = t\n          if (draw((t - start) * 0.001)) {\n            requestAnimationFrame(frame)\n          } else {\n            resolve(async () => this.waitForFirstInput())\n          }\n        }\n\n        requestAnimationFrame(frame)\n      }),\n      this.awaitReloadEvent()\n    ])\n  }\n\n  /** Draw the two axes */\n  drawAxes() {\n    this.marker.clear()\n    this.marker.drawArrow({x: -0.98, y: 0}, {x: 0.98, y: 0})\n    this.marker.drawArrow({x: 0, y: -0.98}, {x: 0, y: 0.98})\n    this.marker.drawText(this.axes[0], {x: -0.03, y: -1}, 'NW')\n    this.marker.drawText(this.axes[1], {x: -0.08, y: 1}, 'SW')\n    this.marker.drawText(this.axes[2], {x: -1, y: 0}, 'SE')\n    this.marker.drawText(this.axes[3], {x: 0.9, y: 0}, 'SW')\n  }\n\n  /** Draw a circle or an arrow whether to two points are close */\n  drawPathPreview(from: Vector, to: Vector) {\n    const length = to.sub(from).len()\n    if (length >= CIRCLE_TRESHOLD) this.marker.drawArrow(from, to)\n    else if (length >= Number.EPSILON)\n      this.marker.drawCircle(from, length, '#000')\n  }\n}\n\nconst app = new HomeApp({\n  board: document.querySelector('#board'),\n  duration: document.querySelector('#duration'),\n  tooltip: document.querySelector('#duration-tooltip'),\n  databasePicker: document.querySelector('#database-picker'),\n  loadDatabase: document.querySelector('#load-database'),\n  databaseUrl: document.querySelector('#database-url')\n})\nvoid app.run()\n"],"names":["MusicFields","$d056521e609c6c8dd585a17aed2c9f50$export$512e94db3067f2de","$68aa8fbeb24221aedbaa0c8ad21d0d61$export$ff95bcce2965a200","async","element","eventName","Promise","resolve","addEventListener","event","once","$68aa8fbeb24221aedbaa0c8ad21d0d61$export$7b898e4855efaed4","string","replace","$d27e883a2513b8eeb6f2043a49c6620e$export$a00f0b081d75722f","x","y","Object","startPoint","endPoint","projectile","v","sub","normalize","scale","dot","add","[object Object]","this","s","theta","Math","cos","sin","sqrt","len2","length","len","Number","EPSILON","Error","$d27e883a2513b8eeb6f2043a49c6620e$export$d9f9145a3d2de879","canvas","fromX","toX","fromY","toY","pixelsPerUnit","pixelsPerUnit1","pixelRatio","pixelRatio1","context","getContext","resize","clear","width","height","style","lineWidth","clearRect","lineJoin","lineCap","fillStyle","strokeStyle","from","to","canvasFrom","toCanvasVector","canvasTo","ctx","arrow","beginPath","moveTo","lineTo","stroke","firstPoint","rotate","PI","secondPoint","closePath","fill","points","color","canvasVector","point","slice","radiusPx","center","arc","radius","text","direction","margin","h","font","vect","w","measureText","fillText","$bcfef3000e103e68c368d295fb5567ea$var$defaultDatabases","$bcfef3000e103e68c368d295fb5567ea$var$musicToVect","music","X","Y","board","duration","duration1","tooltip","databasePicker","loadDatabase","databaseUrl","musics","databases","Map","checkedDatabases","eventTarget","EventTarget","$board","$duration","$tooltip","$databasePicker","marker","window","devicePixelRatio","innerHTML","value","preventDefault","addDatabase","dispatchEvent","CustomEvent","url","database","fetch","json","musixy","set","state","file","db","all","map","file1","then","response","db1","loadedDatabases","Set","axes","get","join","hydrateDatabasePicker","loadMusics","groups","name","entries","group","i","dbs","values","$fieldset","document","createElement","next","axesId","$radio","type","id","checked","$label","htmlFor","append","$legend","i1","$p","$label1","$checkbox","has","c","delete","push","resetApp","drawAxes","querySelector","waitForFirstInput","race","size","fromCanvasPoint","offsetX","offsetY","waitForSecondClick","awaitReloadEvent","lastPoint","drawPreview","drawPathPreview","transition","makePlaylist","removeEventListener","playlist","makeArrowPlaylist","makeCirclePlaylist","localStorage","setItem","JSON","stringify","parse","getItem","displayPlaylist","distances","sort","a","b","p1","p2","music1","pop","Duration","projections","firstMusic","firstMusicDistance","lastMusic","lastMusicDistance","projection","orthographicProjection","projectionLength","sections","maxSectionLength","maxSection","maxI","section","splice","sectionFrom","sectionTo","t","section1","section2","realPlaylist","unshift","$playlist","html","Title","Artist","encodeURI","YoutubeId","drawPlaylist","vectors","draw","time","chain","cumulatedLength","previous","dots","vector","delta","drawPolyLine","drawPoint","start","frame","requestAnimationFrame","drawArrow","drawText","drawCircle","run"],"version":3,"file":"index.d844bdeb.js.map"}